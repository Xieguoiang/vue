<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>four</title>
</head>
<body>
	



	<script>
		
		`
		==============================================================================
		生命周期
		# beforeCreate    在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
		# created		  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
		# beforeMount     在挂载开始之前被调用：相关的 render 函数首次被调用。         该钩子在服务器端渲染期间不被调用。
		# mounted 		  在挂载完成 之后调用        该钩子在服务器端渲染期间不被调用。
		# beforeUpdate 	  数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。
			该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。
		# updated         更新之后调用
		# activated   	  keep-alive 组件激活时调用。
		# deactivated 	  keep-alive 组件停止后调用。
		# beforeDestroy   实例销毁之前调用。在这一步，实例仍然完全可用
		# destroyed       实例销毁之后调用。
		# errorCaptured    2.5新增  看官网

		

		=======================================================================================


		计算(computed)属性
		模板内的表达式不应该包含太多的逻辑，对于任何复杂逻辑，都应当使用计算属性

		computed属性和methods不同的是计算属性是基于它们的依赖进行缓存的。

		computed属性和computed属性，通常更好的想法是使用computed属性而不是命令式的watch回调。虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的watcher。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。




		============================================================================================

		数组更新检测
		数组的变异方法(mutation method，会改变被这些方法调用的原始数组)会触发视图更新，有以下七个：

		push()
		pop()
		shift()
		unshift()
		splice()
		sort()
		reverse()
		当使用非变异方法时，可以用新数组替换旧数组，或者使用Vue.set方法。`
	</script>
</body>
</html>